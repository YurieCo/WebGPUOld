// Generated by CoffeeScript 1.3.3
(function() {
  var ArrayBitSet, BitSet, ConciseBitSet, HashGenerator, SHA1, ScalableBloomFilter, SlicedBloomFilter, StrictSlicedBloomFilter,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  SHA1 = require('crypto/sha1').hex_hmac_sha1;

  /*
  # The sliced bloom filter optimizes the filter by partitioning the bit array into a segment
  # that is reserved for each hash function. Note that once the the @count > @capacity the % failure
  # is now > @errorRate!
  #
  # This implementation is derived from 'Scalable Bloom Filters':
  #
  # http://en.wikipedia.org/wiki/Bloom_filter#CITEREFAlmeidaBaqueroPreguicaHutchison2007
  */


  SlicedBloomFilter = (function() {

    SlicedBloomFilter.fromJSON = function(json) {
      var s, slices, _i, _j, _len, _len1, _ref, _ref1;
      slices = [];
      if (json.slicesType === 'ArrayBitSet') {
        _ref = json.slices;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          s = _ref[_i];
          slices.push(ArrayBitSet.fromJSON(s));
        }
      } else {
        _ref1 = json.slices;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          s = _ref1[_j];
          slices.push(ConciseBitSet.fromJSON(s));
        }
      }
      return new SlicedBloomFilter(json.capacity, json.errorRate, slices, json.count, json.hashStartChar);
    };

    function SlicedBloomFilter(capacity, errorRate, slices, count, hashStartChar) {
      var cnt, i, _i, _ref;
      this.capacity = capacity != null ? capacity : 100;
      this.errorRate = errorRate != null ? errorRate : .001;
      this.slices = slices != null ? slices : null;
      this.count = count != null ? count : 0;
      this.hashStartChar = hashStartChar != null ? hashStartChar : 'h';
      this.bitsPerInt = 32;
      this.totalSize = Math.floor(this.capacity * Math.abs(Math.log(this.errorRate)) / Math.pow(Math.log(2), 2));
      if (this.totalSize < 0) {
        throw "total size is bigger than an int! " + this.totalSize;
      }
      this.numSlices = Math.ceil(Math.log(1 / this.errorRate) / Math.log(2));
      cnt = 0;
      this.sliceLen = Math.ceil(this.totalSize / this.numSlices);
      this.hashgenerator = new HashGenerator(this.hashStartChar, this.sliceLen);
      if (!this.slices) {
        this.slicesType = 'ArrayBitSet';
        this.slices = [];
        for (i = _i = 0, _ref = this.numSlices - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          this.slices.push(new ArrayBitSet(this.sliceLen, this.bitsPerInt));
        }
      } else {
        if (!(this.slices[0] instanceof ArrayBitSet)) {
          this.slicesType = 'ConciseBitSet';
        }
      }
      if (this.slices.length !== this.numSlices) {
        throw "numSlices doesn't match slices: " + this.slices.length + " != " + this.numSlices;
      }
      if (this.slices[0].length * this.bitsPerInt < this.sliceLen) {
        throw "sliceLen doesn't match slice lengths: " + this.sliceLen + " !< " + (this.slices[0].length * this.bitsPerInt);
      }
    }

    SlicedBloomFilter.prototype.add = function(k) {
      var i, _i, _ref;
      this.hashgenerator.reset(k);
      for (i = _i = 0, _ref = this.numSlices - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        this.slices[i].add(this.hashgenerator.getIndex());
      }
      this.count++;
      return this;
    };

    SlicedBloomFilter.prototype.has = function(k) {
      var i, index, _i, _ref;
      this.hashgenerator.reset(k);
      for (i = _i = 0, _ref = this.numSlices - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        index = this.hashgenerator.getIndex();
        if (!this.slices[i].has(index)) {
          return false;
        }
      }
      return true;
    };

    SlicedBloomFilter.prototype.readOnlyInstance = function() {
      var ROslices, s, sbf, _i, _len, _ref;
      ROslices = [];
      _ref = this.slices;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        s = _ref[_i];
        ROslices.push(s.toConciseBitSet());
      }
      sbf = new SlicedBloomFilter(this.capacity, this.errorRate, ROslices, this.count, this.hashStartChar);
      return sbf;
    };

    return SlicedBloomFilter;

  })();

  /*
  # Strict filter: fail if you attempt to stuff more into it than its configured to handle.
  */


  StrictSlicedBloomFilter = (function(_super) {

    __extends(StrictSlicedBloomFilter, _super);

    StrictSlicedBloomFilter.fromJSON = function(json) {
      var sbl;
      sbl = SlicedBloomFilter.fromJSON(json);
      return new StrictSlicedBloomFilter(sbl.capacity, sbl.errorRate, sbl.slices, sbl.count, sbl.hashStartChar);
    };

    function StrictSlicedBloomFilter(capacity, errorRate, slices, count, hashStartChar) {
      this.capacity = capacity != null ? capacity : 100;
      this.errorRate = errorRate != null ? errorRate : .001;
      this.slices = slices != null ? slices : null;
      this.count = count != null ? count : 0;
      this.hashStartChar = hashStartChar != null ? hashStartChar : 'h';
      StrictSlicedBloomFilter.__super__.constructor.call(this, this.capacity, this.errorRate, this.slices, this.count, this.hashStartChar);
    }

    StrictSlicedBloomFilter.prototype.add = function(k) {
      if (this.count >= this.capacity) {
        throw "count should be <= capacity, no more room: " + this.count + " <= " + this.capacity;
      }
      return StrictSlicedBloomFilter.__super__.add.call(this, k);
    };

    return StrictSlicedBloomFilter;

  })(SlicedBloomFilter);

  /*
  # A hash function. It is intended to be used to:
  #
  # 1: set the key/length of indexes
  # 2: fetch several random indexes.
  #
  # This class automatically handles the hash generation - minimizing the
  # total number of hashes generated.
  */


  HashGenerator = (function() {

    function HashGenerator(hashStartChar, len) {
      this.hashStartChar = hashStartChar;
      this.len = len;
      this.hexCharsNeeded = Math.ceil(Math.log(this.len) / Math.log(16));
    }

    /*
      # Anchor the generator on to a specific key. Reset any hash data.
    */


    HashGenerator.prototype.reset = function(key) {
      this.key = key;
      this.hashCnt = 0;
      return this.hash = "";
    };

    HashGenerator.prototype.getIndex = function() {
      var c;
      if (this.hash === "" || this.hashIdx > this.hash.length - this.hexCharsNeeded) {
        this.hash = SHA1("" + this.hashStartChar + "-" + this.hashCnt + "-" + this.key, this.key) + this.hash.slice(this.hashIdx, this.hash.length);
        this.hashCnt++;
        this.hashIdx = 0;
      }
      if (this.len > Math.pow(2, 31)) {
        console.log("WARNING: watch out, I think this is too big. Key: '" + this.key + "' Len: " + this.len);
      }
      c = parseInt(this.hash.slice(this.hashIdx, this.hashIdx + this.hexCharsNeeded), 16);
      this.hashIdx += this.hexCharsNeeded;
      return c;
    };

    return HashGenerator;

  })();

  /*
  # abstract bit set class. common handy methods.
  */


  BitSet = (function() {

    function BitSet() {}

    BitSet.prototype.add = function(b) {};

    BitSet.prototype.has = function(b) {
      return false;
    };

    BitSet.prototype.bitStringAsWord = function(str) {
      var b, bit, offset, _i, _len;
      b = 0;
      offset = 31;
      for (_i = 0, _len = str.length; _i < _len; _i++) {
        bit = str[_i];
        if (bit !== ' ') {
          b = b | (parseInt(bit) << offset--);
        }
      }
      return b;
    };

    BitSet.prototype.wordAsBitString = function(w) {
      var i, str, _i;
      str = "";
      for (i = _i = 31; _i >= 0; i = --_i) {
        if ((i + 1) % 4 === 0 && i !== 31) {
          str += " ";
        }
        if (this.bitOfWordSet(w, i)) {
          str += "1";
        } else {
          str += "0";
        }
      }
      return str;
    };

    BitSet.prototype.bitOfWordSet = function(w, i) {
      return (w & (1 << i)) !== 0;
    };

    BitSet.prototype.bitsOfWordSet = function(w) {
      var cnt, i, _i;
      cnt = 0;
      for (i = _i = 0; _i <= 31; i = ++_i) {
        if (this.bitOfWordSet(w, i)) {
          cnt++;
        }
      }
      return cnt;
    };

    BitSet.prototype.wordMatches = function(w, p) {
      var allMatch, i, _i;
      allMatch = true;
      for (i = _i = 0; _i <= 31; i = ++_i) {
        allMatch = this.bitOfWordSet(w, i) === this.bitOfWordSet(p, i);
        if (!allMatch) {
          return false;
        }
      }
      return true;
    };

    return BitSet;

  })();

  /*
  # Straight up array based bit set (well, we use the bits of the ints in the array).
  */


  ArrayBitSet = (function(_super) {

    __extends(ArrayBitSet, _super);

    ArrayBitSet.fromJSON = function(json) {
      return new ArrayBitSet(json.size, json.bitsPerInt, json.data, json.max);
    };

    function ArrayBitSet(size, bitsPerInt, data, max) {
      var cnt;
      this.size = size;
      this.bitsPerInt = bitsPerInt != null ? bitsPerInt : 32;
      this.data = data != null ? data : [];
      this.max = max;
      cnt = 0;
      while (cnt < this.size) {
        this.data.push(0);
        cnt += this.bitsPerInt;
      }
    }

    ArrayBitSet.prototype.computeIndexes = function(bit) {
      return [Math.floor(bit / this.bitsPerInt), Math.ceil(bit % this.bitsPerInt)];
    };

    ArrayBitSet.prototype.add = function(bit) {
      var mask, parts;
      if (bit >= this.size * this.bitsPerInt) {
        throw "Array is setup for " + (this.size * this.bitsPerInt) + " bits, but bit " + bit + " was attempted.";
      }
      parts = this.computeIndexes(bit);
      mask = 1 << parts[1] - 1;
      this.data[parts[0]] = this.data[parts[0]] | mask;
      if (bit > this.max) {
        return this.max = bit;
      }
    };

    ArrayBitSet.prototype.has = function(bit) {
      var mask, parts;
      if (bit >= this.size * this.bitsPerInt) {
        return false;
      }
      parts = this.computeIndexes(bit);
      mask = 1 << parts[1] - 1;
      return (this.data[parts[0]] & mask) !== 0;
    };

    ArrayBitSet.prototype.toConciseBitSet = function() {
      var cbs, cnt, i, max, _i, _ref;
      cbs = new ConciseBitSet();
      cnt = 0;
      max = 0;
      for (i = _i = 0, _ref = this.size * this.bitsPerInt; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        if (this.has(i)) {
          cnt++;
          max = i;
          cbs.add(i);
        }
      }
      return cbs;
    };

    ArrayBitSet.prototype.printObject = function() {
      var i, w, _i, _len, _ref, _results;
      console.log("size = " + this.size);
      _ref = this.data;
      _results = [];
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        w = _ref[i];
        _results.push(console.log("word " + i + " : " + (this.wordAsBitString(w))));
      }
      return _results;
    };

    return ArrayBitSet;

  })(BitSet);

  /*
  # CONCISE bit set.
  # unfortunately you can't use the CONCISE bit for for a writeable bloom filter so
  # we are just using it for the read only version - for its space saving features.
  #
  # This bitmap is really only useful if the bloom filter is mostly full, or mostly empty. In that
  # middle state, there aren't sparse areas of 1s or 0s for it to compress.
  #
  # If the # of items in the bloom filter is near the capacity of the filter, the standard array
  # is almost always better (uses less space)
  */


  ConciseBitSet = (function(_super) {

    __extends(ConciseBitSet, _super);

    ConciseBitSet.fromJSON = function(json) {
      return new ConciseBitSet(json.words, json.top, json.max, json.count);
    };

    function ConciseBitSet(words, top, max, count) {
      this.words = words != null ? words : [];
      this.top = top != null ? top : 0;
      this.max = max != null ? max : 0;
      this.count = count != null ? count : 0;
    }

    ConciseBitSet.prototype.add = function(i) {
      var b, f, zeroBlocks;
      if (this.words.length === 0) {
        f = Math.floor(i / 31.0);
        switch (f) {
          case 0:
            this.top = 0;
            break;
          case 1:
            this.top = 1;
            this.setWord(0, 0x80000000);
            break;
          default:
            this.top = 1;
            this.setWord(0, f - 1);
        }
        this.setWord(this.top, 0x80000000 | (1 << (i % 31)));
      } else {
        b = i - this.max + (this.max % 31);
        if (b >= 31) {
          zeroBlocks = Math.floor(b / 31.0) - 1;
          b = b % 31;
          if (zeroBlocks > 0) {
            this.appendSequence(zeroBlocks, 0);
          }
          this.appendLiteral(0x80000000 | (1 << b));
        } else {
          this.setWord(this.top, this.words[this.top] | (1 << b));
          if (this.wordMatches(this.words[this.top], 0xffffffff)) {
            this.top = this.top - 1;
            if (this.top < 0) {
              this.words = [];
            }
            if (this.top < 0) {
              this.top = 0;
            }
            this.appendLiteral(0xffffffff);
          }
        }
      }
      this.max = i;
      return this.count++;
    };

    ConciseBitSet.prototype.appendLiteral = function(w) {
      if (this.top === 0 && this.wordMatches(w, 0x80000000) && this.wordMatches(this.words[0], 0x01ffffff)) {
        return;
      }
      if (this.words.length === 0) {
        this.top = 0;
        return this.setWord(this.top, w);
      } else if (this.wordMatches(w, 0x80000000)) {
        if (this.wordMatches(this.words[this.top], 0x80000000)) {
          return this.setWord(this.top, 1);
        } else if ((this.words[this.top] & 0xc0000000) === 0) {
          return this.setWord(this.top, this.words[this.top] + 1);
        } else if (this.containsOneBit(0x7fffffff & this.words[this.top])) {
          return this.setWord(this.top, 1 | ((1 + this.trailingZeros(this.words[this.top])) << 25));
        } else {
          this.top++;
          return this.setWord(this.top, w);
        }
      } else if (this.wordMatches(w, 0xffffffff)) {
        if (this.wordMatches(this.words[this.top], 0xffffffff)) {
          return this.setWord(this.top, 0x40000000 | 1);
        } else if (this.wordMatches(this.words[this.top] & 0xc0000000, 0x40000000)) {
          return this.setWord(this.top, this.words[this.top] + 1);
        } else if (this.containsOneBit(~this.words[this.top])) {
          return this.setWord(this.top, 0x40000000 | 1 | ((1 + this.trailingZeros(~this.words[this.top])) << 25));
        } else {
          this.top++;
          return this.setWord(this.top, w);
        }
      } else {
        this.top++;
        return this.setWord(this.top, w);
      }
    };

    ConciseBitSet.prototype.appendSequence = function(l, t) {
      t = t & 0x40000000;
      if (l === 1) {
        if (t === 0) {
          return this.appendLiteral(0x80000000);
        } else {
          return this.appendLiteral(0xffffffff);
        }
      } else if (this.words.length === 0) {
        this.top = 0;
        return this.setWord(this.top, t | (l - 1));
      } else if (this.isLiteral(this.words[this.top])) {
        if (t === 0 && this.wordMatches(this.words[this.top], 0x80000000)) {
          return this.setWord(this.top, l);
        } else if (this.wordMatches(t, 0x40000000) || this.wordMatches(this.words[this.top], 0xffffffff)) {
          return this.setWord(this.top, 0x40000000 | l);
        } else if (t === 0 && this.containsOneBit(0x7fffffff & this.words[this.top])) {
          return this.setWord(this.top, l | ((1 + this.trailingZeros(this.words[this.top])) << 25));
        } else if (this.wordMatches(t, 0x40000000) && this.containsOneBit(~this.words[this.top])) {
          return this.setWord(this.top, 0x40000000 | l | ((1 + this.trailingZeros(~this.words[this.top])) << 25));
        } else {
          this.top++;
          return this.setWord(this.top, t | (l - 1));
        }
      } else if (this.wordMatches(this.words[this.top] & 0xc0000000, t)) {
        return this.setWord(this.top, this.words[this.top] + l);
      } else {
        this.top++;
        return this.setWord(this.top, t | (l - 1));
      }
    };

    ConciseBitSet.prototype.setWord = function(i, w) {
      if (i > this.words.length) {
        throw "index i (" + i + ") should be no more than 1 more than @words length (currently " + this.words.length;
      }
      if (this.words.length < i - 1) {
        return this.words.push(w);
      } else {
        return this.words[i] = w;
      }
    };

    ConciseBitSet.prototype.printObject = function() {
      var i, w, _i, _len, _ref, _results;
      console.log("top = " + this.top);
      console.log("max = " + this.max);
      console.log("count = " + this.count);
      _ref = this.words;
      _results = [];
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        w = _ref[i];
        if (i <= this.top) {
          _results.push(console.log("word " + i + " : " + (this.wordAsBitString(w))));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    ConciseBitSet.prototype.isLiteral = function(w) {
      return (w & 0x80000000) !== 0;
    };

    ConciseBitSet.prototype.is01Fill = function(w) {
      return (w & 0x80000000) === 0 && (w & 0x40000000) !== 0;
    };

    ConciseBitSet.prototype.is00Fill = function(w) {
      return (w & 0x80000000) === 0 && (w & 0x40000000) === 0;
    };

    ConciseBitSet.prototype.bitCount = function(arr) {
      var cnt, w, _i, _len;
      if (arr == null) {
        arr = this.words;
      }
      cnt = 0;
      for (_i = 0, _len = arr.length; _i < _len; _i++) {
        w = arr[_i];
        if (this.isLiteral(w)) {
          cnt += this.bitsOfWordSet(w) - 1;
        } else if (this.is01Fill(w)) {
          cnt += 31 + 31 * this.bitsOfWordSet(w & 0x7ffffff);
          cnt -= this.bitsOfWordSet((w >> 25) & 0x1f);
        } else if (this.is00Fill(w)) {
          cnt += this.bitsOfWordSet((w >> 25) & 0x1f);
        } else {
          throw "Should start with 1, or 00 or 01 !?";
        }
      }
      return cnt;
    };

    ConciseBitSet.prototype.has = function(n) {
      var bit, block, w, _i, _len, _ref;
      if (n > this.max || this.words.length === 0 || n < 0) {
        return false;
      }
      block = Math.floor(n / 31.0);
      bit = n % 31;
      _ref = this.words;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        w = _ref[_i];
        if (this.isLiteral(w)) {
          if (block === 0) {
            return (w & (1 << bit)) !== 0;
          }
          block--;
          /*
                  if n - height <= 31
                    return @bitOfWordSet(w,n-height)
                  height += 31
          */

        } else if (this.is01Fill(w)) {
          if (block === 0 && this.wordMatches(0x0000001f & (w >> 25) - 1, bit)) {
            return false;
          }
          block -= (w & 0x01FFFFFF) + 1;
          if (block < 0) {
            return true;
          }
        } else if (this.is00Fill(w)) {
          if (block === 0 && this.wordMatches((w >> 25) - 1, bit)) {
            return true;
          }
          block -= (w & 0x01FFFFFF) + 1;
          if (block < 0) {
            return false;
          }
        }
      }
      return false;
    };

    ConciseBitSet.prototype.containsOneBit = function(w) {
      return (w & (w - 1)) === 0;
    };

    ConciseBitSet.prototype.trailingZeros = function(v) {
      var c, foundOne;
      c = 0;
      if (v !== 0) {
        foundOne = false;
        v = v ^ 0x80000000;
        while (!foundOne) {
          if ((v & 1) === 0) {
            c++;
          } else {
            foundOne = true;
          }
          v >>= 1;
        }
      } else {
        c = 32;
      }
      return c;
    };

    return ConciseBitSet;

  })(BitSet);

  /*
  # A bloom filter that grows automatically.
  # Consists of several SlicedBloomFilter's to ensure that the
  # filter maintains its % error.
  #
  # http://en.wikipedia.org/wiki/Bloom_filter#CITEREFAlmeidaBaqueroPreguicaHutchison2007
  */


  ScalableBloomFilter = (function() {

    ScalableBloomFilter.fromJSON = function(json) {
      var f, filters, _i, _len, _ref;
      filters = [];
      _ref = json.filters;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        f = _ref[_i];
        filters.push(StrictSlicedBloomFilter.fromJSON(f));
      }
      return new ScalableBloomFilter(json.startcapacity, json.targetErrorRate, filters, json.stages, json.r, json.count);
    };

    function ScalableBloomFilter(startcapacity, targetErrorRate, filters, stages, r, count) {
      this.startcapacity = startcapacity != null ? startcapacity : 100;
      this.targetErrorRate = targetErrorRate != null ? targetErrorRate : .001;
      this.filters = filters != null ? filters : null;
      this.stages = stages != null ? stages : 4;
      this.r = r != null ? r : 0.85;
      this.count = count != null ? count : 0;
      this.P_0 = this.targetErrorRate * (1 - this.r);
      if (!this.filters) {
        this.filters = [new StrictSlicedBloomFilter(this.startcapacity, this.P_0, null, 0, 'h0')];
      }
    }

    ScalableBloomFilter.prototype.add = function(k) {
      var f, _i, _len, _ref;
      this.count = 0;
      _ref = this.filters;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        f = _ref[_i];
        this.count += f.count;
        if (f.count < f.capacity) {
          f.add(k);
          this.count++;
          return this;
        }
      }
      this.count++;
      this.filters.push(new StrictSlicedBloomFilter(this.startcapacity * Math.pow(this.stages, this.filters.length), this.P_0 * Math.pow(this.r, this.filters.length), null, 0, "h" + this.filters.length));
      this.filters[this.filters.length - 1].add(k);
      return this;
    };

    ScalableBloomFilter.prototype.has = function(k) {
      var f, _i, _len, _ref;
      _ref = this.filters;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        f = _ref[_i];
        if (f.has(k)) {
          return true;
        }
      }
      return false;
    };

    ScalableBloomFilter.prototype.readOnlyInstance = function() {
      var ROfilters, f, _i, _len, _ref;
      ROfilters = [];
      _ref = this.filters;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        f = _ref[_i];
        ROfilters.push(f.readOnlyInstance());
      }
      return new ScalableBloomFilter(this.startcapacity, this.targetErrorRate, ROfilters, this.stages, this.r, this.count);
    };

    return ScalableBloomFilter;

  })();

  module.exports = {
    BloomFilter: SlicedBloomFilter,
    StrictBloomFilter: StrictSlicedBloomFilter,
    ScalableBloomFilter: ScalableBloomFilter,
    ConciseBitSet: ConciseBitSet,
    ArrayBitSet: ArrayBitSet
  };

}).call(this);
