// Generated by CoffeeScript 1.3.3
(function() {
  var SlicedBloomFilter, allow_keyword, allow_program, boom_filter, build_filter, contains_invalid_include, in_filter, normalize, remove_special_chars, sandbox_black_list, split_program, trim, _,
    _this = this;

  _ = require('underscore');

  SlicedBloomFilter = (require('./bloom_filter')).BloomFilter;

  sandbox_black_list = (require('./sandbox_blacklist')).list;

  boom_filter = null;

  build_filter = function() {
    var black_list;
    black_list = sandbox_black_list;
    boom_filter = new SlicedBloomFilter(black_list.length);
    return _.each(black_list, function(keyword) {
      return boom_filter.add(keyword);
    });
  };

  in_filter = function(keyword) {
    var has;
    if (boom_filter) {
      has = boom_filter.has(keyword);
      if (has) {
        return _.any(sandbox_black_list, function(elem) {
          return elem === keyword;
        });
      } else {
        return false;
      }
    } else {
      return true;
    }
  };

  trim = function(str0) {
    var str;
    str = str0;
    return (str.replace(/^\s\s*/, '')).replace(/\s\s*$/, '');
  };

  remove_special_chars = function(str0) {
    var str;
    str = str0;
    return str.replace(/[();]/, '');
  };

  normalize = function(str0) {
    var str;
    str = trim(str0);
    str = remove_special_chars(str);
    return str;
  };

  allow_keyword = function(keyword0) {
    var keyword;
    keyword = normalize(keyword0);
    if (keyword === '') {
      return true;
    } else {
      return (in_filter(keyword)) === false;
    }
  };

  split_program = function(prog0) {
    var prog;
    prog = prog0.replace(/\".*\"/, "");
    prog = prog.split("\n");
    prog = _.flatten(prog);
    prog = _.map(prog, function(line) {
      return line.split("\r");
    });
    prog = _.flatten(prog);
    prog = _.map(prog, function(line) {
      return line.split("\t");
    });
    prog = _.flatten(prog);
    prog = _.map(prog, function(line) {
      return line.split(";");
    });
    prog = _.flatten(prog);
    prog = _.map(prog, function(line) {
      return line.split(",");
    });
    prog = _.flatten(prog);
    prog = _.map(prog, function(line) {
      return line.split("(");
    });
    prog = _.flatten(prog);
    prog = _.map(prog, function(line) {
      return line.split(")");
    });
    prog = _.flatten(prog);
    prog = _.map(prog, function(line) {
      return line.split("[");
    });
    prog = _.flatten(prog);
    prog = _.map(prog, function(line) {
      return line.split("]");
    });
    prog = _.flatten(prog);
    prog = _.map(prog, function(line) {
      return line.split("*");
    });
    prog = _.flatten(prog);
    prog = _.map(prog, function(line) {
      return line.split("\"");
    });
    prog = _.flatten(prog);
    prog = _.map(prog, function(line) {
      return line.split("<<<");
    });
    prog = _.flatten(prog);
    prog = _.map(prog, function(line) {
      return line.split(">>>");
    });
    prog = _.flatten(prog);
    prog = _.map(prog, function(line) {
      return line.split(" ");
    });
    return _.flatten(prog);
  };

  contains_invalid_include = function(prog) {
    var bad_include, res;
    prog = prog.split("\n");
    prog = _.flatten(prog);
    prog = _.map(prog, function(line) {
      return line.split("\r");
    });
    prog = _.flatten(prog);
    prog = _.map(prog, function(line) {
      return trim(line);
    });
    prog = _.flatten(prog);
    bad_include = null;
    res = _.any(prog, function(line) {
      if (line.indexOf("#include") !== -1) {
        if (line.indexOf("wb.h") !== -1) {
          return false;
        } else {
          bad_include = line;
          return true;
        }
      } else {
        return false;
      }
    });
    if (res) {
      return bad_include;
    } else {
      return null;
    }
  };

  allow_program = function(prog, call_back) {
    var bad_include, keyword, keywords;
    if (!(prog != null)) {
      return false;
    }
    if (boom_filter === null) {
      build_filter();
    }
    bad_include = contains_invalid_include(prog);
    if (bad_include) {
      return call_back(true, bad_include);
    } else {
      keywords = split_program(prog);
      keyword = _.filter(keywords, function(keyword) {
        return allow_keyword(keyword) === false;
      });
      if (keyword.length === 0) {
        return call_back(null);
      } else {
        return call_back(true, keyword[0]);
      }
    }
  };

  module.exports = {
    allow_program: allow_program
  };

}).call(this);
