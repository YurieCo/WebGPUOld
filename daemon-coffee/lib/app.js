// Generated by CoffeeScript 1.3.3
(function() {
  var Logger, address, app, broadcast, compile_run, config, control, data_processor, dataset_exists_cache, express, fs, get_mp_config, has_all_mp_data, has_data_cache, has_mp_config, has_mp_data, ifaces, logger, mp_config_cache, os, path, port, register, ring_buffer, server, _,
    _this = this;

  _ = require('underscore');

  express = require('express');

  fs = require('fs.extra');

  path = require('path');

  config = require('./config');

  control = require('./control');

  compile_run = require('./compile_run');

  data_processor = require('./data_processor');

  broadcast = (require('./broadcast')).broadcast;

  register = (require('./broadcast')).register;

  Logger = require('bunyan');

  app = express();

  address = null;

  ring_buffer = new Logger.RingBuffer({
    limit: 200
  });

  logger = new Logger({
    name: 'wbDaemon',
    streams: [
      {
        stream: process.stdout,
        level: 'debug'
      }, {
        path: config.log_file_path,
        level: 'trace'
      }, {
        type: 'raw',
        stream: ring_buffer,
        level: 'trace'
      }
    ],
    serializers: {
      req: Logger.stdSerializers.req,
      res: Logger.stdSerializers.res
    }
  });

  app.configure(function() {
    app.set('port', config.port);
    app.use(express.methodOverride());
    app.use(express.bodyParser());
    app.use(express.errorHandler({
      dumpExceptions: true,
      showStack: true
    }));
    return app.use(app.router);
  });

  app.configure('development', function() {
    return app.use(express.errorHandler({
      dumpExceptions: true,
      showStack: true
    }));
  });

  app.configure('production', function() {
    return app.use(express.errorHandler());
  });

  app.get('/stop', function(req, res) {
    return control.stop({
      request: req,
      result: res,
      logger: logger
    });
  });

  app.get('/clear_tmp', function(req, res) {
    return clear_tmp({
      request: req,
      result: res,
      logger: logger
    }, function(err, params) {
      if (err) {
        return res.send(500, 'unable to clear temporary files');
      } else {
        return res.send({
          status: 'success'
        });
      }
    });
  });

  app.get('/status', function(req, res) {
    return res.send({
      current_process_count: compile_run.current_process_count(),
      number_processes: compile_run.served_processes(),
      address: address.address,
      port: address.port,
      log: ring_buffer.records
    });
  });

  app.get('/log', function(req, res) {
    return res.send(ring_buffer.records);
  });

  app.get('/busy', function(req, res) {
    return res.send(compile_run.current_process_count() >= config.max_processes);
  });

  mp_config_cache = {};

  has_mp_config = function(mp_id) {
    var data, mp_config_file;
    if (mp_config_cache[mp_id] != null) {
      return true;
    } else {
      mp_config_file = path.join(config.mp_dir, mp_id, 'config.txt');
      if (fs.existsSync(mp_config_file)) {
        data = fs.readFileSync(mp_config_file, 'ascii');
        mp_config_cache[mp_id] = JSON.parse(data);
        return true;
      } else {
        return false;
      }
    }
  };

  get_mp_config = function(mp_id) {
    var data, mp_config_file;
    if (mp_config_cache[mp_id] != null) {
      return mp_config_cache[mp_id];
    } else {
      mp_config_file = path.join(config.mp_dir, mp_id, 'config.txt');
      if (fs.existsSync(mp_config_file)) {
        data = fs.readFileSync(config_file, 'ascii');
        mp_config_cache[mp_id] = JSON.parse(data);
        return mp_config_cache[mp_id];
      } else {
        return {};
      }
    }
  };

  dataset_exists_cache = {};

  has_mp_data = function(mp_id, dataset_id) {
    var mp_config, res;
    if ((dataset_exists_cache[mp_id] != null) && dataset_exists_cache[mp_id][dataset_id]) {
      return true;
    } else {
      if (!(dataset_exists_cache[mp_id] != null)) {
        dataset_exists_cache[mp_id] = {};
      }
      mp_config = get_mp_config(mp_id);
      if (_.isEmpty(mp_config.data)) {
        res = true;
      } else {
        res = data_processor.has_data(mp_id, mp_config.data[dataset_id], dataset_id);
      }
      dataset_exists_cache[mp_id][dataset_id] = res;
      return res;
    }
  };

  has_all_mp_data = function(mp_id) {
    var existsQ, required_datasets, required_datasets_length;
    if (dataset_exists_cache[mp_id] != null) {
      return true;
    } else {
      required_datasets = mp_config_cache[mp_id].data;
      required_datasets_length = required_datasets.length;
      existsQ = _.all(_.range(required_datasets.length), function(dataset_id) {
        return has_mp_data(mp_id, dataset_id);
      });
      if (existsQ) {
        return true;
      } else {
        return false;
      }
    }
  };

  app.post('/mp/submit/:id', function(req, res) {
    var data_id, mp_id, program;
    mp_id = req.params.id;
    data_id = parseInt(req.body.data_id);
    program = req.body.program;
console.log("Got request");
    if ((has_mp_config(mp_id)) && (has_mp_data(mp_id, data_id))) {
      return compile_run.compile_run.start({
        status: 'success',
        request: req,
        response: res,
        mp_id: mp_id,
        data_id: data_id,
        program: program,
        mp_config: get_mp_config(mp_id),
        mode: req.body.mode
      });
    } else if (!(has_mp_config(mp_id))) {
      console.log('missing config for mp' + mp_id);
      return res.send({
        status: 'missing config'
      });
    } else {
      console.log('missing dataset for mp' + mp_id);
      return res.send({
        status: 'missing dataset'
      });
    }
  });

  app.post('/mp/config/:id', function(req, res) {
    var body, config_file, dir, json, mp_id;
    mp_id = req.params.id;
    body = req.body;
    dir = path.join(config.mp_dir, mp_id);
    config_file = path.join(dir, 'config.txt');
    if (!fs.existsSync(dir)) {
      fs.mkdirRecursiveSync(dir);
    }
    try {
      json = JSON.parse(body);
    } catch (e) {
      json = body;
    }
    mp_config_cache[mp_id] = json;
    return fs.writeFile(config_file, JSON.stringify(json), 'ascii', function(err) {
      if (err) {
        console.log('unable to write config file for mp' + mp_id);
        return res.send(500, 'unable to open config file');
      } else {
        console.log('wrote config file for mp' + mp_id);
        return res.send(true);
      }
    });
  });

  app.post('/mp/data', function(req, res) {
    var body, dir, file, file_path, mp_id;
    body = req.body;
    mp_id = body.mp;
    file = body.file.split('/');
    dir = path.join(config.mp_dir, '' + mp_id, 'data', file[0]);
    file_path = path.join(dir, file[1]);
    if (!fs.existsSync(dir)) {
      fs.mkdirRecursiveSync(dir);
    }
    return fs.writeFile(file_path, body.data, 'ascii', function(err) {
      if (err) {
        console.log('unable to write data file ' + file_path + ' for mp' + mp_id);
        return res.send(500, 'unable to write data file');
      } else {
        console.log('wrote config data file ' + file.join("/") + ' for mp' + mp_id);
        return res.send(true);
      }
    });
  });

  has_data_cache = {};

  app.get('/mp/has_data', function(req, res) {
    var body, dir, file, file_path, mp_id;
    body = req.body;
    mp_id = body.mp;
    file = body.file;
    if (has_data_cache[mp_id] && has_data_cache[mp_id][file] === true) {
      return res.send(true);
    } else {
      dir = path.join(config.mp_dir, '' + mp_id, 'data');
      file_path = path.join(dir, file);
      return fs.exists(file_path, function(existsQ) {
        if (!(has_data_cache[mp_id] != null)) {
          has_data_cache[mp_id] = {};
        }
        has_data_cache[mp_id][file] = existsQ;
        return res.send(existsQ);
      });
    }
  });

  if (!module.parent) {
    port = app.get('port');
    console.log("Express server listening on port " + port);
    server = app.listen(port);
    address = server.address();
    if (address.address === '0.0.0.0') {
      os = require('os');
      ifaces = os.networkInterfaces();
      _.each(ifaces, function(dev, key) {
        return _.each(dev, function(detail) {
          if (detail.family === 'IPv4' && detail.internal === false) {
            return address.address = detail.address;
          }
        });
      });
    }
    console.log("address = " + address.address);
    broadcast(address);
    setInterval((function() {
      return register(address);
    }), 5000);
    //(require('look')).start(config.look_port, address.address);
  }

}).call(this);
