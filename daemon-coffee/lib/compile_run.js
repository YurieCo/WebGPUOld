// Generated by CoffeeScript 1.3.3
(function() {
  var Logger, async, bunyan, compile_run, compute_correctness, compute_keywords, config, current_process_count, dataset_exists, dataset_exists_cache, dataset_location_cache, events, execFile, find_nvcc_exe, fs, getExtension, get_compile_command, get_dataset, grade_program, lib_extension, nvcc_exe, nvcc_path, nvvc_paths, os, path, quote, result_is_correct, run_program, sandbox, served_processes, sys, system_id, temp, _;

  os = require('os');

  async = require('async');

  fs = require('fs.extra');

  temp = require('temp');

  path = require('path');

  bunyan = require('bunyan');

  execFile = (require('child_process')).execFile;

  _ = require('underscore');

  events = require('events');

  sys = require('sys');

  config = require('./config');

  sandbox = require('./sandbox');

  current_process_count = 0;

  served_processes = 0;

  compile_run = function() {
    return events.EventEmitter.call(this);
  };

  compile_run.super_ = events.EventEmitter;

  compile_run.prototype = Object.create(events.EventEmitter.prototype, {
    constructor: {
      value: compile_run,
      enumerable: false
    }
  });

  compile_run = new compile_run();

  Logger = function(dir) {
    var log, ring_buffer;
    ring_buffer = new bunyan.RingBuffer({
      limit: 200
    });
    log = new bunyan({
      name: 'wbCUDA',
      streams: [
        {
          path: path.join(dir, 'process.log'),
          level: 'trace'
        }, {
          stream: ring_buffer,
          level: 'info',
          type: 'raw'
        }
      ],
      src: true
    });
    return {
      log: log,
      ring_buffer: ring_buffer,
      id: served_processes
    };
  };

  nvvc_paths = function() {
    var default_envs, paths;
    paths = process.env['PATH'].split(';');
    if (process.platform === 'win32') {
      default_envs = ["CUDA_PATH_V5_0", "CUDA_PATH_V4_2", "CUDA_PATH_V4_2", "CUDA_PATH_V4_1", "CUDA_PATH_V4_0", "CUDA_BIN_PATH"];
    } else {
      paths.push('/usr/local/cuda/bin');
      paths.push('/opt/nvidia/cuda/bin');
      default_envs = ["PATH", "CUDA_BIN_PATH"];
    }
    default_envs.forEach(function(env) {
      if (process.env[env]) {
        return paths.push(process.env[env]);
      }
    });
    return paths;
  };

  find_nvcc_exe = function() {
    var dir, exe, file, _i, _len, _ref;
    exe = process.platform === 'win32' ? 'nvcc.exe' : 'nvcc';
    _ref = nvvc_paths();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      dir = _ref[_i];
      file = path.join(dir, exe);
      if (fs.existsSync(file)) {
        return {
          exe: file,
          path: dir
        };
      }
      file = path.join(dir, 'bin', exe);
      if (fs.existsSync(file)) {
        return {
          exe: file,
          path: dir
        };
      }
    }
    return null;
  };

  if (find_nvcc_exe() != null) {
    nvcc_exe = find_nvcc_exe().exe;
    nvcc_path = find_nvcc_exe().path;
    if (nvcc_path.indexOf('bin', nvcc_path.length - 3) !== -1) {
      nvcc_path += '/..';
    }
  } else {
    nvcc_exe = null;
  }

  quote = function(str) {
    return '"' + str + '"';
  };

  compile_run.on('respond', function(self) {
    var logger, ring_buffer, toc,
      _this = this;
    logger = self.logger;
    ring_buffer = logger.ring_buffer;
    toc = process.hrtime(self.tic);
    self.response.send({
      status: 'success',
      type: 'compute',
      log: ring_buffer.records,
      elapsed_time: toc,
      process_count: current_process_count,
      created_on: new Date(),
      logger_id: logger.id
    });
    current_process_count--;
    return ;
/*
    return fs.rmrf(self.dir, function(err) {
      return {};
    });
*/
  });

  compile_run.on('respond_grades', function(self) {
    var logger, ring_buffer, toc,
      _this = this;
    logger = self.logger;
    ring_buffer = logger.ring_buffer;
    toc = process.hrtime(self.tic);
    self.response.send({
      status: 'success',
      type: 'grades',
      log: ring_buffer.records,
      elapsed_time: toc,
      process_count: current_process_count,
      created_on: new Date(),
      logger_id: logger.id,
      grades: self.grades
    });
    current_process_count--;
    return ;
/*
    return fs.rmrf(self.dir, function(err) {
      return {};
    });
*/
  });

  compile_run.on('error', function(self) {
    var logger, ring_buffer, toc,
      _this = this;
    logger = self.logger;
    ring_buffer = logger.ring_buffer;
    toc = process.hrtime(self.tic);
    self.response.send({
      status: 'success',
      type: 'error',
      elapsed_time: toc,
      process_count: current_process_count,
      log: ring_buffer.records,
      created_on: new Date(),
      logger_id: logger.id
    });
    current_process_count--;
    return ;
/*
    return fs.rmrf(self.dir, function(err) {
      return {};
    });
*/
  });

  compile_run.on('sandbox-error', function(self) {
    var logger, ring_buffer, toc,
      _this = this;
    logger = self.logger;
    ring_buffer = logger.ring_buffer;
    toc = process.hrtime(self.tic);
    self.response.send({
      status: 'success',
      type: 'sandboxed',
      elapsed_time: toc,
      process_count: current_process_count,
      log: ring_buffer.records,
      created_on: new Date(),
      logger_id: logger.id
    });
    current_process_count--;
    return ;
/*
    return fs.rmrf(self.dir, function(err) {
      return {};
    });
*/
  });

  run_program = function(self, call_back) {
    var dataset, dir, logger, output_file, output_file_base_name, program, run_props, tic;
    logger = self.logger;
    dir = self.dir;
    program = path.join(dir, 'program');
    if (self.mp_config.output_type === 'image') {
      output_file_base_name = 'output.ppm';
    } else {
      output_file_base_name = 'output.raw';
    }
    output_file = path.join(dir, output_file_base_name);
    tic = process.hrtime();
    dataset = get_dataset(self, self.data_id);
    run_props = {
      'cwd': dir,
      'timeout': config.process_timeout
    };
    if (system_id === 'Linux-x86-64') {
      run_props['env'] = {
        'LD_LIBRARY_PATH': dir + ":" + nvcc_path + '/lib64'
      };
    }
    return execFile(program, ['-i', dataset.input.join(','), '-o', output_file, '-e', dataset.expected_output, '-t', self.mp_config.output_type], run_props, function(err, stdout, stderr) {
      var json, res, tmp, toc,
        _this = this;
      res = {};
      toc = process.hrtime(tic);
      res.program_run_time = toc;
      res.ProgramElapsedTime = toc;
      res.ProgramStdoutOutput = stdout;
      if (err) {
        res.ProgramStderrOutput = stderr;
        if (err.killed) {
          res.ProgramKilled = true;
          res.ProgramFailed = 'Program was terminated based on timeout policy.';
        } else if (err.signal === 'SIGSYS') {
          res.ProgramKilled = true;
          res.ProgramFailed = 'Program was terminated based on security policy.';
        } else {
          res.ProgramFailed = 'Failed to run input program.';
        }
      } else {
        tmp = stderr.split('==$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$');
        stderr = tmp[0];
        if ((stderr.indexOf('MEMORYERROR')) !== -1) {
          stderr = stderr.split('\n');
          stderr = _.filter(stderr, function(line) {
            return (line.indexOf('MEMORYERROR')) === -1;
          });
          stderr = stderr.join('\n');
          res.ProgramKilled = true;
          res.ProgramFailed = 'Program was terminated based on memory allocation policy.';
          res.ProgramStderrOutput = stderr;
        } else {
          res.ProgramStderrOutput = stderr;
          if (tmp.length > 0) {
            try {
              json = JSON.parse(tmp[1]);
              if (_.isEmpty(dataset.input)) {
                res.Correctness = true;
                res.SolutionData = {};
                res.SolutionData.InputData = [];
                res.SolutionData.Stderr = stderr;
                res.SolutionData.DatasetId = 'None';
                res.SolutionData.CorrectQ = true;
                res.SolutionData.Message = "Solution is correct.";
              } else {
                res.SolutionData = json.Solution;
                res.SolutionData.InputData = [];
                res.Correctness = res.UserOutput === res.ExpectedOutput;
              }
              res.ProgramTimer = JSON.stringify(json.Timer);
              res.ProgramLogger = JSON.stringify(json.Logger);
            } catch (e) {
              ({});
            }
          }
        }
      }
      return call_back(err, self, res);
    });
  };

  dataset_location_cache = {};

  get_dataset = function(self, dataset_id) {
    var dataset_config, dir, id, mp_id, res;
    mp_id = self.mp_id;
    dataset_id = dataset_id.toString();
    if ((dataset_location_cache[mp_id] != null) && (dataset_location_cache[mp_id][dataset_id] != null)) {
      return dataset_location_cache[mp_id][dataset_id];
    } else {
      dir = path.join(config.mp_dir, mp_id, 'data');
      id = parseInt(dataset_id);
      dataset_config = self.mp_config.data[id];
      if (!dataset_config) {
        res = {
          input: [],
          output: ""
        };
      } else {
        res = {
          input: _.map(dataset_config.input, function(input) {
            return path.join(dir, input);
          }),
          expected_output: path.join(dir, dataset_config.output)
        };
      }
      if (!(dataset_location_cache[mp_id] != null)) {
        dataset_location_cache[mp_id] = {};
      }
      dataset_location_cache[mp_id][dataset_id] = res;
      return res;
    }
  };

  dataset_exists_cache = {};

  dataset_exists = function(self, dataset_id) {
    var dataset, inputs_exists, mp_id, output_exists;
    mp_id = self.mp_id;
    if ((dataset_exists_cache[mp_id] != null) && (dataset_exists_cache[mp_id][dataset_id] != null)) {
      return dataset_exists_cache[mp_id][dataset_id];
    } else {
      dataset = get_dataset(self, dataset_id);
      if (id < datasets.length) {
        inputs_exists = _.all(dataset.input, function(file) {
          return path.existsSync(file);
        });
        output_exists = path.existsSync(dataset.output);
        if (inputs_exists && output_exists) {
          if (!(dataset_exists_cache[mp_id] != null)) {
            dataset_exists_cache[mp_id] = {};
          }
          dataset_exists_cache[mp_id][dataset_id] = true;
          return true;
        }
      }
      return false;
    }
  };

  grade_program = function(self, dataset_id, prev, call_back) {
    if (dataset_exists(self, dataset_id)) {
      self.data_id = dataset_id;
      return run_program(self, function(err, self, res) {
        var next;
        next = prev;
        next.push(res);
        return grade_program(self, dataset_id + 1, next, call_back);
      });
    } else {
      return call_back(self, prev);
    }
  };

  result_is_correct = function(data) {
    return data.Correctness === true;
  };

  compute_correctness = function(self, run_data) {
    var correctness, correctness_score, dataset_id;
    dataset_id = 0;
    correctness = {};
    correctness_score = 0;
    _.each(run_data, function(data) {
      var score;
      if (result_is_correct(data)) {
        score = self.mp_config.data[dataset_id].score;
        correctness[dataset_id] = score;
        correctness_score += score;
      }
      return dataset_id++;
    });
    return {
      correctness_grade: correctness,
      correctness_score: correctness_score
    };
  };

  if (!String.prototype.contains) {
    String.prototype.contains = function(arg) {
      return !!~this.indexOf(arg);
    };
  }

  compute_keywords = function(self) {
    var keyword_id, keywords_grade, keywords_score, mp_config, program;
    program = self.program;
    mp_config = self.mp_config;
    if (mp_config.required_key_words != null) {
      keyword_id = 0;
      keywords_grade = {};
      keywords_score = 0;
      _.each(mp_config.required_key_words, function(key_config) {
        var key, score;
        key = key_config.data;
        score = key_config.score;
        if (program.contains(key)) {
          keywords_score += score;
          keywords_grade[keyword_id] = score;
        }
        return keyword_id++;
      });
      return {
        keywords_grade: keywords_grade,
        keywords_score: keywords_score
      };
    } else {
      return null;
    }
  };

  compile_run.on('grade-program', function(self) {
    return grade_program(self, 0, [], function(self, run_data) {
      var grades;
      self.run_data = run_data;
      grades = compute_correctness(self, run_data);
      self.correctness_score = grades.correctness_score;
      self.correctness_grade = grades.correctness_grade;
      grades = compute_keywords(self);
      if (grades) {
        self.keyword_score = grades.keyword_score;
        self.keyword_grade = grades.keyword_grade;
      }
      return compile_run.emit('respond_grades', self);
    });
  });

  compile_run.on('run-program', function(self) {
    return run_program(self, function(err, self, res) {
      var logger;
      logger = self.logger;
      if (res.ProgramElapsedTime != null) {
        logger.log.info({
          err: 'ProgramElapsedTime'
        }, res.ProgramElapsedTime);
      }
      if (res.ProgramStdoutOutput != null) {
        logger.log.info({
          err: 'ProgramStdoutOutput'
        }, res.ProgramStdoutOutput);
      }
      if (res.ProgramStderrOutput != null) {
        logger.log.error({
          err: 'ProgramStderrOutput'
        }, res.ProgramStderrOutput);
      }
      if (res.ProgramKilled != null) {
        logger.log.error({
          err: 'ProgramKilled'
        }, res.ProgramKilled);
      }
      if (res.ProgramFailed != null) {
        logger.log.error({
          err: 'ProgramFailed'
        }, res.ProgramFailed);
      }
      if (res.ProgramTimer != null) {
        logger.log.error({
          err: 'ProgramTimer'
        }, res.ProgramTimer);
      }
      if (res.ProgramLogger != null) {
        logger.log.error({
          err: 'ProgramLogger'
        }, res.ProgramLogger);
      }
      if (res.SolutionData != null) {
        logger.log.error({
          err: 'SolutionData'
        }, JSON.stringify(res.SolutionData));
      }
      if (res.Correctness != null) {
        logger.log.error({
          err: 'Correctness'
        }, res.Correctness);
      }
      if (err) {
        return compile_run.emit('error', self);
      } else {
        return compile_run.emit('respond', self);
      }
    });
  });

  compile_run.on('compile-program', function(self) {
    var batch_file, dir, logger, tic;
    logger = self.logger;
    dir = self.dir;
    tic = process.hrtime();
    batch_file = self.batch_file;
    return execFile(batch_file, {
      'cwd': dir,
      'timeout': config.compile_timeout
    }, function(err, stdout, stderr) {
      var toc;
      toc = process.hrtime(tic);
      logger.log.info({
        err: 'CompileElapsedTime'
      }, toc);
      logger.log.info({
        err: 'CompilerStdoutOutput'
      }, stdout);
      logger.log.error({
        err: 'CompilerStderrOutput'
      }, stderr);
      if (err) {
        if (err.killed) {
          logger.log.error({
            err: 'CompileFailed'
          }, 'Compilation was terminated based on timeout policy.');
        } else {
          logger.log.error({
            err: 'CompileFailed'
          }, 'Was not able to compile input program.');
        }
        return compile_run.emit('error', self);
      } else if (self.mode === 'grade') {
        return compile_run.emit('grade-program', self);
      } else {
        return compile_run.emit('run-program', self);
      }
    });
  });

  getExtension = function(filename) {
    var ext;
    if (filename === '') {
      return '';
    } else {
      ext = (path.extname(filename || '')).split('.');
      return ext[ext.length - 1];
    }
  };

  system_id = process.platform === 'win32' ? 'Windows-x86-64' : 'Linux-x86-64';

  lib_extension = process.platform === 'win32' ? 'dll' : 'a';

  get_compile_command = function(self) {
    var cmd, copyfn, defines, dir, jansson_dir, jansson_files, jansson_lib_name, logger, new_line, program_file, wb_dir, wb_files, wb_lib_name, wb_lib_path,
      _this = this;
    cmd = '';
    new_line = '\n';
    logger = self.logger;
    dir = self.dir;
    program_file = self.program_file;
    wb_dir = path.join(dir, 'c-tools');
    jansson_dir = path.join(dir, 'c-tools', 'jansson');
    wb_lib_name = 'wb';
    wb_lib_path = path.join(wb_dir, system_id, 'lib' + wb_lib_name + '.so');
    if (system_id === 'Linux-x86-64' && (fs.existsSync(wb_lib_path))) {
      wb_files = ['-l' + wb_lib_name, '-L' + (path.join(wb_dir, system_id))];
      if (system_id === 'Linux-x86-64') {
        copyfn = fs.symlink;
      } else {
        copyfn = fs.copy;
      }
      copyfn(wb_lib_path, path.join(dir, 'lib' + wb_lib_name + '.so'), function(err) {
        if (err) {
          return console.log(err);
        }
      });
    } else {
      wb_files = fs.readdirSync(wb_dir);
      wb_files = _.filter(wb_files, function(file) {
        return getExtension(file) === 'cpp';
      });
      wb_files = _.map(wb_files, function(file) {
        return path.join(wb_dir, file);
      });
    }
    jansson_lib_name = 'jansson.';
    if (system_id === 'Linux-x86-64') {
      jansson_lib_name = 'lib' + jansson_lib_name;
    }
    if ((system_id != null) && (fs.existsSync(path.join(jansson_dir, system_id, jansson_lib_name + lib_extension)))) {
      jansson_files = path.join(jansson_dir, system_id, jansson_lib_name + lib_extension);
      jansson_files = [jansson_files];
    } else {
      jansson_files = fs.readdirSync(jansson_dir);
      jansson_files = _.filter(jansson_files, function(file) {
        return getExtension(file) === 'c';
      });
      jansson_files = _.map(jansson_files, function(file) {
        return path.join(jansson_dir, file);
      });
    }
    if (process.platform === 'win32') {
      new_line = '\r\n';
      cmd += 'call \"c:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\vcvarsall.bat\" amd64' + new_line;
    } else {
      cmd += '#!/bin/sh' + new_line;
      cmd += 'chmod 777 libwb.so' + new_line;
    }
    defines = ' -DWB_USE_JSON ' + '-DWB_USE_COURSERA ';
    if (process.platform === 'linux') {
      defines += '-DWB_USE_SANDBOX ';
      defines += '-DWB_USE_CUSTOM_MALLOC ';
    }
    cmd += (quote(nvcc_exe)) + defines + ' -arch=sm_20 -O3 -I. ' + ' -I ' + wb_dir + ' -I ' + jansson_dir + ' ' + (wb_files.join(' ')) + ' ' + (jansson_files.join(' ')) + ' ' + program_file;
    if (process.platform !== 'win32') {
      cmd += " -lrt -lstdc++ -lm ";
    }
    cmd += ' -o ' + 'program' + ' 2>&1' + new_line;
console.log(cmd);
    return cmd;
  };

  compile_run.on('write-compile-command', function(self) {
    var build_file_base_name, dir, file, logger;
    dir = self.dir;
    logger = self.logger;
    build_file_base_name = process.platform === 'win32' ? 'build.bat' : 'build.sh';
    file = path.join(dir, build_file_base_name);
    return fs.open(file, 'w+', function(err, fd) {
      var buffer, compile_command;
      if (err) {
        logger.log.err('Failed to open ' + file);
        compile_run.emit('error', self);
      }
      logger.log.info('Opened ' + file);
      compile_command = get_compile_command(self);
      buffer = new Buffer(compile_command);
      return fs.write(fd, buffer, 0, buffer.length, null, function(err, written, buffer) {
        if (err) {
          logger.log.err('Failed to write to ' + file);
          compile_run.emit('error', self);
        }
        logger.log.info('Wrote ' + compile_command + ' to file ' + file);
        return fs.close(fd, function(err) {
          if (err) {
            logger.log.err('Failed to close ' + file);
            compile_run.emit('error', self);
          }
          if (process.platform !== 'win32') {
            fs.chmodSync(file, '777');
          }
          logger.log.info('Closed ' + file);
          self.batch_file = file;
          return compile_run.emit('compile-program', self);
        });
      });
    });
  });

  compile_run.on('copy-support-files', function(self) {
    var reccopyfn;
    if (system_id === 'Linux-x86-64') {
      reccopyfn = fs.symlink;
    } else {
      reccopyfn = fs.copyRecursive;
    }
    return reccopyfn(path.join(config.c_tools_dir), path.join(self.dir, 'c-tools'), function(err) {
      var copyfn, inputs_and_outputs;
      if (err && err.Error) {
        logger.log.err({
          err: 'CopySupportFiles'
        }, 'Failed to copy support files to ' + self.dir);
        return compile_run.emit('error', self);
      } else if ((self.inputs != null) && (self.output != null)) {
        inputs_and_outputs = [];
        _.each(self.inputs, function(ii) {
          return inputs_and_outputs.push(ii);
        });
        inputs_and_outputs.push(self.output);
        if (system_id === 'Linux-x86-64') {
          copyfn = fs.symlink;
        } else {
          copyfn = fs.copy;
        }
        _.each(inputs_and_outputs, function(file) {
          return copyfn(file, path.join(self.dir, path.basename(file)), function(err) {
            return null;
          });
        });
        return compile_run.emit('write-compile-command', self);
      } else {
        return compile_run.emit('write-compile-command', self);
      }
    });
  });

  compile_run.on('write-program-file', function(self) {
    var dir, file, logger, program;
    dir = self.dir;
    program = self.program;
    logger = self.logger;
    file = path.join(dir, 'program.cu');
    console.log("Compiling new program in " + dir);
    return fs.open(file, 'w+', function(err, fd) {
      var buffer;
      if (err) {
        logger.log.err('Failed to open ' + file);
        compile_run.emit('error', self);
      }
      logger.log.info('Opened ' + file);
      buffer = new Buffer(program);
      return fs.write(fd, buffer, 0, buffer.length, null, function(err, written, buffer) {
        if (err) {
          logger.log.err('Failed to write to ' + file);
          compile_run.emit('error', self);
        }
        logger.log.info('Wrote ' + program + ' to file ' + file);
        return fs.close(fd, function(err) {
          if (err) {
            logger.log.err('Failed to close ' + file);
            compile_run.emit('error', self);
          }
          logger.log.info('Closed ' + file);
          self.program_file = file;
          return compile_run.emit('copy-support-files', self);
        });
      });
    });
  });

  compile_run.on('check-sandbox', function(self) {
    var logger, program, _self,
      _this = this;
    _self = self;
    logger = self.logger;
    program = self.program;
    return sandbox.allow_program(program, function(err, keyword) {
      if (err === null) {
        return compile_run.emit('write-program-file', _self);
      } else {
        logger.log.error({
          err: 'SandboxedKeyword'
        }, keyword);
        logger.log.error({
          err: 'Sandboxed'
        }, 'The keyword ' + keyword + ' is not allowed in this sandboxed environment.');
        return compile_run.emit('sandbox-error', _self);
      }
    });
  });

  compile_run.start = function(params) {
    if (nvcc_exe != null) {
      return temp.mkdir(config.tmpdir_prefix, function(err, dir) {
        var log;
        if (!err) {
          current_process_count++;
          served_processes++;
          log = Logger(dir);
          return compile_run.emit('check-sandbox', {
            mp_id: params.mp_id,
            tic: process.hrtime(),
            dir: dir,
            logger: log,
            request: params.request,
            response: params.response,
            program: params.program,
            data_id: params.data_id,
            mp_config: params.mp_config,
            mode: params.mode
          });
        } else {
          console.log("Was not able to create temporary directory");
          return process.exit(1);
        }
      });
    } else {
      console.log("Was not able to find nvcc compiler");
      return process.exit(1);
    }
  };

  module.exports = {
    compile_run: compile_run,
    current_process_count: function() {
      return current_process_count;
    },
    served_processes: function() {
      return served_processes;
    }
  };

}).call(this);
