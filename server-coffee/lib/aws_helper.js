// Generated by CoffeeScript 1.3.3
(function() {
  var Ec2, Logger, amazon, awssum, config, copy_file_to_instance, copy_file_to_instances, ec2, execute_command_on_instances, fmt, for_each_instance, for_each_instance_dns_name, for_each_instance_id, for_each_running_instance, for_each_running_instance_dns_name, for_each_running_instance_id, for_instance_dns_names, for_instance_ids, for_instances, for_running_instance_dns_names, for_running_instance_ids, for_running_instances, get_instances, log, ring_buffer, run_instances, scp, ssh, terminate_instance, terminate_running_instances, _;

  config = require('./config');

  _ = require('underscore');

  fmt = require('fmt');

  awssum = require('awssum');

  amazon = awssum.load('amazon/amazon');

  Ec2 = (awssum.load('amazon/ec2')).Ec2;

  scp = require('./scp');

  ssh = require('./ssh');

  Logger = require('bunyan');

  ring_buffer = new Logger.RingBuffer({
    limit: 200
  });

  ec2 = new Ec2({
    'accessKeyId': config.aws_key_id,
    'secretAccessKey': config.aws_key_secret,
    'region': config.aws_region
  });

  log = new Logger({
    name: 'wbAWS',
    streams: [
      {
        stream: process.stdout,
        level: 'debug'
      }, {
        path: config.aws_log_file_path,
        level: 'trace'
      }, {
        type: 'raw',
        stream: ring_buffer,
        level: 'trace'
      }
    ],
    src: true
  });

  get_instances = function(err, data) {
    var add_instance, instances, item, iter, _i, _len;
    instances = [];
    if (err && err.Body && err.Body.Response) {
      log.error({
        err: 'GetInstance'
      }, err.Body.Response.Errors);
    } else if (err != null) {
      log.error({
        err: 'GetInstance'
      }, 'Failed to get instances.');
    } else {
      item = data.Body.DescribeInstancesResponse.reservationSet.item;
      add_instance = function(inst) {
        var ii, _i, _len, _results;
        if (inst.item != null) {
          return add_instance(inst.item);
        } else if (_.isArray(inst)) {
          _results = [];
          for (_i = 0, _len = inst.length; _i < _len; _i++) {
            ii = inst[_i];
            _results.push(add_instance(ii));
          }
          return _results;
        } else {
          try {
            return instances.push(inst);
          } catch (e) {
            return log.error({
              err: 'Exception'
            }, 'While getting instances.');
          }
        }
      };
      for (_i = 0, _len = item.length; _i < _len; _i++) {
        iter = item[_i];
        add_instance(iter.instancesSet);
      }
    }
    return instances;
  };

  for_each_instance = function(call_back) {
    return ec2.DescribeInstances(function(err, data) {
      var inst, instances, _i, _len, _results;
      instances = get_instances(err, data);
      _results = [];
      for (_i = 0, _len = instances.length; _i < _len; _i++) {
        inst = instances[_i];
        _results.push(call_back(inst));
      }
      return _results;
    });
  };

  for_instances = function(call_back) {
    return ec2.DescribeInstances(function(err, data) {
      var instances;
      instances = get_instances(err, data);
      return call_back(instances);
    });
  };

  for_each_running_instance = function(call_back) {
    return for_each_instance(function(instance) {
      try {
        if (instance.instanceState.name === 'running') {
          return call_back(null, instance);
        }
      } catch (e) {
        log.error({
          err: 'Exception'
        }, 'While iterating over running instance.');
        return call_back(true);
      }
    });
  };

  for_running_instances = function(call_back) {
    return for_instances(function(instances) {
      var running_instances;
      try {
        running_instances = _.filter(instances, function(instance) {
          return instance.instanceState.name === 'running';
        });
        return call_back(null, instances);
      } catch (e) {
        log.error({
          err: 'Exception'
        }, 'While iterating over instances.');
        return call_back(true);
      }
    });
  };

  for_each_instance_id = function(call_back) {
    return for_each_instance(function(instance) {
      return call_back(instance.instanceId);
    });
  };

  for_instance_ids = function(call_back) {
    return for_instances(function(instance) {
      var ids;
      ids = _.map(instances, function(instance) {
        return instance.instanceId;
      });
      return call_back(ids);
    });
  };

  for_each_running_instance_id = function(call_back) {
    return for_each_running_instance(function(instance) {
      return call_back(instance.instanceId);
    });
  };

  for_running_instance_ids = function(call_back) {
    return for_running_instances(function(instance) {
      var ids;
      ids = _.map(instances, function(instance) {
        return instance.instanceId;
      });
      return call_back(ids);
    });
  };

  for_each_instance_dns_name = function(call_back) {
    return for_each_instance(function(instance) {
      return call_back(instance.dnsName);
    });
  };

  for_instance_dns_names = function(call_back) {
    return for_instances(function(instances) {
      var dnsNames;
      dnsNames = _.map(instances, function(instance) {
        return instance.dnsName;
      });
      return call_back(dnsNames);
    });
  };

  for_each_running_instance_dns_name = function(call_back) {
    return for_each_running_instance(function(instance) {
      return call_back(instance.dnsName);
    });
  };

  for_running_instance_dns_names = function(call_back) {
    return for_running_instances(function(instances) {
      var dnsNames;
      dnsNames = _.map(instances, function(instance) {
        return instance.dnsName;
      });
      return call_back(dnsNames);
    });
  };

  copy_file_to_instance = function(host, file, destination_directory, call_back) {
    return scp.send({
      key: config.aws_ssh_key_file,
      user: config.aws_user,
      host: host,
      file: file,
      path: destination_directory
    }, function(err, stdout, stderr) {
      if (err) {
        log.error({
          err: 'SendingFile'
        }, "Failed to send file " + file + " to " + host + " (" + stderr + ").");
      } else {
        log.info({
          err: 'SendingFile'
        }, "Sending file " + file + " to " + host);
      }
      return call_back(err, stdout, stderr);
    });
  };

  copy_file_to_instances = function(file, destination_directory, call_back) {
    return for_each_running_instance_dns_name(function(addr) {
      return copy_file_to_instance(addr, file, destination_directory, call_back);
    });
  };

  execute_command_on_instances = function(cmd, call_back) {
    return for_each_running_instance_dns_name(function(addr) {
      return ssh.exec(cmd, {
        key: config.aws_ssh_key_file,
        user: config.aws_user,
        host: addr
      }, function(err, stdout, stderr) {
        if (err) {
          log.error({
            err: 'ExecutingCommand'
          }, "Failed to execute command " + cmd + " on " + addr + " (" + stderr + ").");
        } else {
          log.info({
            err: 'ExecutingCommand'
          }, "Executed command " + cmd + " on " + addr + " (" + stdout + ").");
        }
        return call_back(err, stdout, stderr);
      });
    });
  };

  terminate_running_instances = function(n) {
    if (!(n != null)) {
      n = Infinity;
    } else if (n <= 0) {
      return;
    }
    return for_each_running_instance(function(instance) {
      if (n === Infinity || n-- > 0) {
        return ec2.TerminateInstances({
          'InstanceId': instance.instanceId
        }, function(err, data) {
          return log.info({
            err: 'TerminateInstance'
          }, "Terminating instance " + instance.instanceId);
        });
      }
    });
  };

  terminate_instance = function(host) {
    return for_each_running_instance(function(instance) {
      if (instance.dnsName === host) {
        return ec2.TerminateInstances({
          'InstanceId': instance.instanceId
        }, function(err, data) {
          return log.info({
            err: 'TerminateInstance'
          }, "Terminating host " + instance.dnsName);
        });
      }
    });
  };

  run_instances = function(n) {
    n = n != null ? n : 1;
    return ec2.RunInstances({
      'ImageId': config.aws_ami_name,
      'MinCount': n,
      'MaxCount': n,
      'KeyName': config.aws_key_name,
      'InstanceType': config.aws_instance_type,
      'SecurityGroup': config.aws_security_group
    }, function(err, data) {
      var instances, logInstance;
      if (err) {
        return log.error({
          err: 'RunInstance'
        }, err.Body.Response.Errors);
      } else {
        instances = data.Body.RunInstancesResponse.instancesSet.item;
        logInstance = function(inst) {
          if (_.isArray(inst)) {
            return _.each(inst, logInstance);
          } else {
            return log.info({
              err: 'RunInstance'
            }, 'Started instance ' + inst.instanceId);
          }
        };
        return logInstance(instances);
      }
    });
  };

  module.exports = {
    aws_run_instances: run_instances,
    aws_terminate_instances: terminate_running_instances,
    aws_terminate_instance: terminate_instance,
    copy_file_to_instances: copy_file_to_instances,
    copy_file_to_instance: copy_file_to_instance
  };

}).call(this);
