// Generated by CoffeeScript 1.3.3
(function() {
  var add_daemon, current_load, daemon, daemon_info, daemon_is_alive, daemon_is_free, daemon_log, daemons, daemons_count, has_daemon, kill_daemon, launch_daemon, nodes_are_struggling, remove_daemon, run_on_free_daemon, _;

  _ = require('underscore');

  daemon = require('./daemon_interactor');

  daemons = {};

  daemons_count = 0;

  add_daemon = function(host, port, call_back) {
    return has_daemon(host, function(has_daemon) {
      if (has_daemon) {
console.log("Daemon " + host + ":" + port + " already registered");
        return call_back(true);
      } else {
        return daemon.status(host, port, function(err, status) {
          if (err) {
console.log("Daemon " + host + ":" + port + " status invalid");
            return call_back(err);
          } else {
            console.log('Added slave node ' + host);
            daemons_count++;
            daemons[host] = status;
            return call_back(null, status);
          }
        });
      }
    });
  };

  daemon_is_alive = function(host, call_back) {
    return daemon.is_alive(host, function(err, alive, json) {
      if (!alive) {
        console.log('deleted slave node ' + host);
        daemons_count--;
        return daemons[host] = null;
      }
    });
  };

  daemon_is_free = function(host, port, call_back) {
    call_back(true);
    return;
    return daemon.is_free(host, port, function(is_free) {
      return call_back(is_free);
    });
  };

  nodes_are_struggling = function(call_back) {
    return async.map(daemons, daemon_is_struggling, function(results) {
      var busy_count;
      busy_count = _.filter(results, function(daemon) {
        return daemon.busy != null;
      });
      if (busy_count > 0.8 * daemons_count) {
        return call_back(true);
      } else {
        return call_back(false);
      }
    });
  };

  remove_daemon = function(host) {
    if (daemons[host]) {
      daemon.stop(host, function() {
        return {};
      });
      daemons_count--;
      return daemons[host] = null;
    }
  };

  has_daemon = function(daemon_address, call_back) {
    var res;
    res = _.any(daemons, function(value, host) {
      if (host === daemon_address && daemons[host]) {
        return true;
      } else {
        return false;
      }
    });
    return call_back(res);
  };

  run_on_free_daemon = function(call_back) {
    var called;
    called = false;
    _.each(daemons, function(value, host) {
      var port;
      if (daemons[host] && !called) {
        port = daemons[host].port;
        return daemon_is_free(host, port, function(freeQ) {
          if (freeQ && !called) {
            called = true;
            return call_back(null, host, port);
          }
        });
      }
    });
    return null;
  };

  launch_daemon = function(n) {
    if (!(n != null)) {
      return n = 1;
    }
  };

  kill_daemon = function() {};

  current_load = function(call_back) {};

  daemon_info = function(host, call_back) {
    return daemon.status(daemons[host].address, daemons[host].port, call_back);
  };

  daemon_log = function(host, call_back) {
    return daemon.log(daemons[host].address, daemons[host].port, call_back);
  };

  exports.daemons = daemons;

  exports.worker_info = daemon_info;

  exports.worker_log = daemon_log;

  exports.add_daemon = add_daemon;

  exports.has_daemon = has_daemon;

  exports.run_on_free_daemon = run_on_free_daemon;

}).call(this);
