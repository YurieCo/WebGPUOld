// Generated by CoffeeScript 1.3.3
(function() {
  var async, aws, config, daemon_clear_tmp, daemon_compute_program, daemon_current_process_count, daemon_has_config, daemon_has_data, daemon_is_alive, daemon_is_free, daemon_is_struggling, daemon_log, daemon_query, daemon_send_config, daemon_send_data, daemon_status, daemon_stop, data_file_cache, fs, http, log, mp_config_cache, path, read_config_into_cache, request, trim, url, _;

  _ = require('underscore');

  http = require('http');

  request = require('request');

  url = require('url');

  path = require('path');

  fs = require('fs');

  async = require('async');

  log = (require('./log')).log;

  config = require('./config');

  aws = require('./aws_helper');

  daemon_query = function(hostname, path, options, call_back) {
    var body, json, method, port, timeout, uri;
    port = options.port != null ? options.port : config.aws_daemon_running_port;
    method = options.method != null ? options.method : 'GET';
    body = options.body != null ? options.body : {};
    json = options.json != null ? options.json : false;
    timeout = options.timeout != null ? options.timeout : 500000;
    uri = url.format({
      protocol: 'http:',
      hostname: hostname,
      port: port,
      pathname: path,
      timeout: timeout
    });
    return request({
      uri: uri,
      method: method,
      json: json,
      body: body
    }, call_back);
  };

  daemon_stop = function(host, port, call_back) {
    return daemon_query(host, '/stop', {
      method: 'GET',
      json: true,
      port: port
    }, function(err, res, json) {
      return call_back(err, res, json);
    });
  };

  daemon_status = function(host, port, call_back) {
    return daemon_query(host, '/status', {
      method: 'GET',
      json: true,
      port: port
    }, function(err, _, json) {
      return call_back(err, json);
    });
  };

  daemon_is_alive = function(host, port, call_back) {
    return daemon_query(host, '/status', {
      method: 'GET',
      json: true,
      port: port,
      timeout: 2000
    }, function(err, res, json) {
      if (err || !(json != null)) {
        return call_back(false);
      } else {
        return call_back(true);
      }
    });
  };

  daemon_is_struggling = function(host, port, call_back) {
    return daemon_query(host, '/busy', {
      method: 'GET',
      json: true,
      port: port
    }, function(err, res, json) {
      if (err) {
        return call_back(err);
      } else {
        return call_back(null, json);
      }
    });
  };

  daemon_log = function(host, port, call_back) {
    return daemon_query(host, '/log', {
      method: 'GET',
      json: true,
      port: port
    }, function(err, res, json) {
      return call_back(err, json);
    });
  };

  daemon_clear_tmp = function(host, port, call_back) {
    return daemon_query(host, '/clear_tmp', {
      method: 'GET',
      json: true,
      port: port
    }, function(err, res, json) {
      return call_back(err, res, json);
    });
  };

  daemon_is_free = function(host, port, call_back) {
    return daemon_query(host, '/busy', {
      method: 'GET',
      json: true,
      port: port
    }, function(err, res, busyQ) {
      if (err) {
        return call_back(false);
      } else {
        return call_back(!busyQ);
      }
    });
  };

  daemon_has_config = function(host, port, mp, call_back) {
    return daemon_query(host, '/mp/has_config/' + mp, {
      method: 'GET',
      json: true,
      port: port
    }, function(err, res, json) {
      return call_back(err, res, json);
    });
  };

  mp_config_cache = {};

  read_config_into_cache = function(mp, call_back) {
    var config_path;
    config_path = path.join('..', 'mp', mp.toString(), 'config.txt');
    if (!fs.existsSync(config_path)) {
      return call_back(true);
    } else {
      return fs.readFile(config_path, 'ascii', function(err, data) {
        var mp_config_data;
        if (err) {
          return call_back(err);
        } else {
          mp_config_data = JSON.parse(data);
          mp_config_cache[mp] = mp_config_data;
          return call_back(mp_config_data);
        }
      });
    }
  };

  daemon_send_config = function(host, port, mp, call_back) {
    var send_mp_config;
    console.log('sending mp config file for mp ' + mp + ' to ' + host + ':' + port);
    send_mp_config = function(data) {
      return daemon_query(host, '/mp/config/' + mp, {
        method: 'POST',
        json: true,
        body: data,
        port: port
      }, function(err, res, json) {
        return call_back(err);
      });
    };
    if (mp_config_cache[mp]) {
      return send_mp_config(mp_config_cache[mp]);
    } else {
      return read_config_into_cache(mp, function(data) {
        return send_mp_config(data);
      });
    }
  };

  daemon_has_data = function(host, port, mp, file, call_back) {
    return daemon_query(host, '/mp/has_data', {
      method: 'GET',
      json: true,
      port: port,
      body: {
        mp: mp,
        file: file
      }
    }, function(err, res, json) {
      return call_back(err, res, json);
    });
  };

  data_file_cache = {};

  daemon_send_data = function(host, port, mp, call_back) {
    var mp_config, send_data, send_file;
    send_file = function(file, body, mp) {
      return daemon_has_data(host, port, mp, file, function(err, res, data) {
        if (err || data === false) {
          console.log('sending data ', file);
          return daemon_query(host, '/mp/data', {
            method: 'POST',
            json: true,
            port: port,
            body: {
              mp: mp,
              file: file,
              data: body
            }
          }, function(err, res, data) {
            return {};
          });
        }
      });
    };
    send_data = function(data, mp) {
      var data_files;
      data_files = _.flatten([data.input, data.output]);
      return async.map(data_files, function(file) {
        var file_path;
        if ((data_file_cache[mp] != null) && (data_file_cache[mp][file] != null)) {
          return send_file(file, data_file_cache[mp][file], mp);
        } else {
          file_path = path.join('..', 'mp', mp.toString(), 'data', file);
          if (!fs.existsSync(file_path)) {
            return console.log('file does not exist ', file_path);
          } else {
            return fs.readFile(file_path, 'ascii', function(err, data) {
              if (err) {
                return console.log('unable to read file ', file_path);
              } else {
                if (data_file_cache[mp]) {
                  data_file_cache[mp][file] = data;
                } else {
                  data_file_cache[mp] = {};
                  data_file_cache[mp][file] = data;
                }
                return send_file(file, data, mp);
              }
            });
          }
        }
      }, function(err, res) {
        return call_back(err);
      });
    };
    if (mp_config_cache[mp]) {
      mp_config = mp_config_cache[mp];
      return _.map(mp_config.data, function(data) {
        return send_data(data, mp);
      });
    } else {
      console.log("MP Config ", mp, " is not in the cache.");
      return read_config_into_cache(mp, function(_) {
        return daemon_send_data(host, port, mp, call_back);
      });
    }
  };

  daemon_current_process_count = function(host, port, call_back) {
    return daemon_query(host, '/current_process_count', {
      method: 'GET',
      json: true,
      port: port
    }, function(err, res, json) {
      return call_back(err, res, json.current_process_count);
    });
  };

  trim = function(string) {
    return string.replace(/^\s*|\s*$/g, '');
  };

  daemon_compute_program = function(host, port, mp_id, body, call_back) {
    console.log('requesting computation from ' + host + ':' + port);
    return daemon_query(host, '/mp/submit/' + mp_id, {
      method: 'POST',
      json: true,
      port: port,
      body: body
    }, function(err, res, json) {
      var data, entry, process_log_element, _i, _len;
      if (err) {
        return call_back(err, res);
      } else if (json != null) {
        data = {};
        log = json.log;
        data.status = json.status;
        if (json.type === 'compute' || json.type === 'error' || json.type === 'sandboxed') {
          data.id = json.id;
          data.created_on = json.created_on;
          data.elapsed_time = json.elapsed_time;
          data.process_count = json.process_count;
          process_log_element = function(entry) {
            if (entry.err != null) {
              try {
                return data[entry.err] = JSON.parse(entry.msg);
              } catch (e) {
                return data[entry.err] = trim(entry.msg);
              }
            }
          };
          for (_i = 0, _len = log.length; _i < _len; _i++) {
            entry = log[_i];
            process_log_element(entry);
          }
        }
        return call_back(err, res, data);
      } else {
        return call_back(err);
      }
    });
  };

  exports.send_config = daemon_send_config;

  exports.send_data = daemon_send_data;

  exports.is_struggling = daemon_is_struggling;

  exports.is_alive = daemon_is_alive;

  exports.is_free = daemon_is_free;

  exports.stop = daemon_stop;

  exports.log = daemon_log;

  exports.status = daemon_status;

  exports.compute = daemon_compute_program;

}).call(this);
